go version  查看go版本
go env #查看go环境变量
go get 地址 #下载远程依赖
go list -m all #查看项目使用的模块
go mod tidy  #添加丢失的模块并删除未使用的模块 (拉取项目后，使用该命令下载相应包)
go mod init #在项目下执行
go generate #

命令参考(https://blog.csdn.net/qq_43405330/article/details/119854821)


export GO111MODULE=on  (参考https://blog.csdn.net/weixin_43272542/article/details/115154147)
export GOPROXY=https://goproxy.cn,direct #配置镜像源为国内
新版本的go不需要在gopath部署项目，可以在任意地方新建项目

go build #在项目目录下直接执行go build，会生成一个以上及目录为名称的字节码文件，执行该字节码文件即可启动服务
go build -o server main.go#在项目目录下直接执行该命令，会生成一个名称为server的字节码文件(-o指定生成字节码文件的名称)，执行该字节码文件即可启动服务


go项目初始化:
1.mkdir go_project(项目目录)
2.新建main.go测试文件 (这里可以执行go run main.go查看运行结果)
3.要执行go build命令，需要先执行执行go mod init 项目目录名称(如:go mod init go_project) 然后执行 go mod tidy命令下载包
4.运行go build 生成的字节码文件


PS:使用github.com/gorilla/websocket这个包时,运行exmaple/chat示例报错是应为这个项目下既有vendor目录又有go.mod,
所以需要使用go mod vendor命令将项目中go.mod总是用的包拷贝到vendor目录下然后继续执行



获取变量类型:
package main
import (
    "fmt"
    "reflect"
)
func main() {
    var num float64 = 3.14
    // 方法1:
    println(reflect.TypeOf(num).Name())
    // 方法2:
    fmt.Println(reflect.TypeOf(num))
    // 方法3:
    fmt.Printf(`%T`, num)
}

示例编程:
示例代码文件main.go:
package main
import "fmt"
func main() {
    fmt.Println("hello, world")
}
代码解读:
和 Java 类似，Go 使用包作为基本单位来管理代码（可以类比为 PHP 中的命名空间），每个 Go 源代码文件的开头都是一个 package 声明，
表示该文件中 Go 代码所属的包。包是 Go 语言里最基本的分发单位，也是工程管理中依赖关系的体现。
要生成 Go 可执行程序，必须建立一个名字为 main 的包，并且在该包中包含一个叫 main() 的主函数，该函数是 Go 可执行程序的执行起点，这一点和 C 语言和
 Java 语言很像，后续编译 Go 项目程序的时候也要从包含 main 包的文件开始。Go 语言的 main() 函数不能带参数，也不能定义返回值。

在包声明之后，是一系列的 import 语句，用于导入该程序所依赖的包（可类比为 PHP 中通过 use 引入其它命名空间的类来理解）。
由于本示例程序用到了Println() 函数，所以需要导入该函数所属的 fmt 包。

有一点需要注意，与 Java 和 PHP 不同，在 Go 语言中，不得包含在源代码文件中没有用到的包，否则 Go 编译器会报编译错误。
这与下面的强制函数左花括号 { 的放置位置以及之后会提到的函数名的大小写规则，均体现了 Go 语言在语言层面解决软件工程问题的设计哲学。

所有 Go 函数（包括在面向对象编程中会提到的类型成员函数）都以关键字 func 开头（这一点与 PHP、Java、JavaScript 等语言通过 function 定义函数不同）。
另外在 Go 函数中，左花括号 { 必须函数定义行的末尾，不能另起一行，否则 Go 编译器报告编译错误:
syntax error: unexpected semicolon or newline before {


另外，与 Python、JavaScript 类似，Go 程序并不要求在每个语句后面加上分号表示语句结束，这也是与 PHP、Java 等语言的不同之处。
最后，函数体很简单，就是调用 fmt 包提供的 Println 函数打印「hello,world」这行字符串，Go 语言可以直接通过包名+「.」号引用定义在该包中的函数。


编译 & 运行程序
对以上代码含义有了大致的了解后，我们接下来要编译并运行第一个 Go 程序，和 PHP 不同，Go 语言是编译型的静态语言（和 Java、C 一样），
在运行 Go 程序之前，先要将其编译成二进制可执行文件，我们可以通过 Go 语言提供的 go build 命令对 Go 程序进行编译，
然后运行编译后的可执行文件执行 Go 程序代码:

可以看到，代码执行成功，打印出了「hello，world」。此外，我们还可以通过 go run 命令来达到同样的效果，该命令将编译和执行指令合二为一，
会在编译之后立即执行相应的可执行文件显示执行结果:

初识变量:
需要注意的是在 Go 语言中，通过 var 来声明变量，并且可以将匿名函数赋值给变量以便后续使用，此外，还可以通过 := 运算符来声明并初始化变量，这个时候，
不需要通过 var 声明该变量，比如 args := os.Args 就是如此，需要明确的是，虽然看起来有点和动态语言声明变量类似，但与 PHP 不同，Go 是强类型语言，
只不过底层会自动根据赋值判断对应变量的类型，如果你试图声明一个没有初始化值的变量，就会报错。

配置 GOPATH 环境变量:
在 Windows 中，则可以通过配置环境变量 GOPATH 来实现，将你的项目根目录完整路径拷贝过去就好了(新版本的go,项目不需要建在gopath下)。和 PATH 环境变量一样，
GOPATH 也可以支持一次配置多个路径，并且路径和路径之间用冒号分隔。

GOPATH 的用处是 Go 语言在编译程序时，会从 GOPATH 配置的路径里面去查找源文件并完成构建。


1.1:变量的申明:
对于纯粹的变量声明，Go 语言引入了关键字 var，并且将类型信息放在变量名之后，此外，变量声明语句不需要使用分号作为结束符
（实际上，所有的 Go 语句都不需要分号作为结束符，这一点和 JavaScript 和 Python 很像），比如我们要声明一个类型为 int 的变量 v1，
示例如下:var v1 int

1.2:一次申明多个变量:
var (
    v1 int 
    v2 string
）

示例:
var v1 int            // 整型
var v2 string         // 字符串
var v3 bool           // 布尔型
var v4 [10]int        // 数组，数组元素类型为整型
var v5 struct {       // 结构体，成员变量 f 的类型为64位浮点型
    f float64
} 
var v6 *int           // 指针，指向整型
var v7 map[string]int   // map（字典），key为字符串类型，value为整型
var v8 func(a int) int  // 函数，参数类型为整型，返回值类型为整型

需要注意的是，变量在声明之后，系统会自动将变量值初始化为对应类型的零值，比如上述 v1 的值为 0，v2 的值空字符串，v3 的值为 false，
依次类推，我们打印上述变量的值

如果变量名包含多个单词，Go 语言变量命名规则遵循驼峰命名法，即首个单词小写，每个新单词的首字母大写，如 userName，
但如果你的全局变量希望能够被外部包所使用，则需要将首个单词的首字母也大写。

1.3:变量的申明同时初始化:
var v1 int = 10   // 方式一，常规的初始化操作
var v2 = 10       // 方式二，此时变量类型会被编译器自动推导出来
v3 := 10          // 方式三，可以省略 var，编译器可以自动推导出v3的类型

以上三种用法的效果是完全一样的。与第一种用法相比，第三种用法更简捷，推荐用这种方式对变量进行初始化。
这里 Go 语言也引入了另一个 PHP 语言中没有的运算符 :=，用于明确表达同时对变量进行声明和初始化。

此外我们还看到，对变量同时进行声明和初始化时，指定类型已不再是必需的，Go 编译器可以从初始化表达式的右值推导出该变量应该声明为哪种类型
（纯粹的变量声明时可不能省略类型，那样会编译器会报错），这让 Go 语言看起来有点像动态类型语言，但是与 PHP 等动态语言不同的是，
这个推导是在编译期做的，而不是运行时，所以 Go 语言还是不折不扣的静态语言。

错误示例:出现在 := 左侧的变量不应该是已经被声明过的，否则会导致编译错误，比如下面这个写法:
var i int 
i := 2


1.4:多重赋值,交换变量
交换变量:
var i int =1;
var j int =2;
i, j = j, i

多重赋值:i, j := 1, 2

1.5:匿名变量
我们在使用传统的强类型语言编程时，经常会出现这种情况，即在调用函数时为了获取一个值，却因为该函数返回多个值而不得不定义一堆没用的变量。
在 Go 语言中，这种情况可以通过结合使用多重赋值和匿名变量来避免这种丑陋的写法，让代码看起来更加优雅，多重赋值上面已经介绍过，
匿名变量则通过下划线 _ 来声明，任何赋予它的值都会被丢弃。

例子:假设 GetName() 函数的定义如下，它返回两个值，分别为 userName 和 nickName:
func GetName() (userName, nickName string) { 
    return "nonfu", "学院君"
}
若只想获得 nickName，则函数调用语句可以用如下方式实现:
_, nickName := GetName()


2:变量的作用域:
每个变量在程序中都有一定的作用范围，称之为作用域。如果一个变量在函数体外声明，则被认为是全局变量，可以在整个包甚至外部包（变量名以大写字母开头）使用，
不管你声明在哪个源文件里或在哪个源文件里调用该变量。在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。

尽管变量的标识符必须是唯一的，但你可以在某个代码块的内层代码块中使用相同名称的变量，则此时外部的同名变量将会暂时隐藏
（结束内部代码块的执行后隐藏的外部同名变量又会出现，而内部同名变量则被释放），你任何的操作都只会影响内部代码块的局部变量。

关于变量的作用域后面我们在介绍到函数、包、流程控制代码块是还会以具体实例来演示。


3:常量:在 Go 语言中，常量是指编译期间就已知且不可改变的值，常量只可以是数值类型（包括整型、 浮点型和复数类型）、布尔类型、字符串类型等标量类型。
和 PHP 一样，在 Go 语言中，我们可以通过 const 关键字来定义常量（遵循 C 语言的约定）。
3.1:常量定义
通过 const 关键字定义常量时，可以指定常量类型，也可以省略（底层会自动推导），常见的常量定义方式如下:
const Pi float64 = 3.14159265358979323846 
const zero = 0.0 // 无类型浮点常量 
const (          // 通过一个 const 关键字定义多个常量，和 var 类似
    size int64 = 1024
    eof = -1  // 无类型整型常量 
) 
const u, v float32 = 0, 3  // u = 0.0, v = 3.0，常量的多重赋值 
const a, b, c = 3, 4, "foo" // a = 3, b = 4, c = "foo", 无类型整型和字符串常量

3.2:预定义常量
Go 语言预定义了这些常量:true、false 和 iota。
前面两个熟悉 PHP 或其他语言的应该都很熟悉，iota 比较特殊，可以被认为是一个可被编译器修改的常量，在每一个 const 关键字出现时被重置为 0，
然后在下一个 const 出现之前，每出现一次 iota，其所代表的数字会自动增 1。
示例:
package main
const (    // iota 被重置为 0
	c0 = iota   // c0 = 0
	c1 = iota   // c1 = 1
	c2 = iota   // c2 = 2
)
const (
    u = iota * 2;  // u = 0
    v = iota * 2;  // v = 2
    w = iota * 2;  // w = 4
)
const x = iota;  // x = 0
const y = iota;  // y = 0

如果两个 const 的赋值语句的表达式是一样的，那么还可以省略后一个赋值表达式。因此，上面的前两个 const 语句可简写为:
const ( 
    c0 = iota 
    c1 
    c2 
)

const ( 
    u = iota * 2 
    v 
    w 
)

3.3:枚举——此外，常量还可以用于枚举。
枚举中包含了一系列相关的常量，比如下面关于一个星期中每天的定义。Go 语言并不支持其他语言用于表示枚举的 enum 关键字，
而是通过在 const 后跟一对圆括号定义一组常量的方式来实现枚举。
注:PHP 本身并不支持枚举，不过我们可以通过 SPL 库提供的 SplEnum 类来实现，此外还有一个第三方扩展包 myclabs/php-enum 可用来实现对枚举的支持。

示例:下面是一个常规的 Go 语言枚举表示法，其中定义了一系列整型常量:
const (
    Sunday = iota 
    Monday 
    Tuesday 
    Wednesday 
    Thursday 
    Friday 
    Saturday 
    numberOfDays
)

3.4:常量的作用域
和函数体外声明的变量一样，以大写字母开头的常量在包外可见（类似于 public 修饰的类属性），比如上面介绍的 Pi、Sunday 等，
而以小写字母开头的常量只能在包内访问（类似于通过 protected 修饰的类属性），比如 zero、numberOfDays 等，后面在介绍包的可见性时还会详细介绍。
函数体内声明的常量只能在函数体内生效。


4.数据类型
基本数据类型的支持:
	布尔类型:bool
	整型:int8、byte、int16、int、uint、uintptr 等
	浮点类型:float32、float64
	复数类型:complex64、complex128
	字符串:string
	字符类型:rune
	错误类型:error
相较于 PHP，多出了字符类型（单个字符）、错误类型和复数类型，PHP 通过系统级配置函数 error_reporting 定义应用的错误报告级别，不区分单独的字符与字符串类型，
Go 还对整型的精度及是否有符号（正数还是负数）做了区分，PHP 则只有一个 int 类型标识整型数据，另外 PHP 通过 float 和 double 来区分浮点型精度，
这一点也是 Go 语言 和 PHP 不一样的地方。

复合类型:
	指针（pointer）
	数组（array）
	切片（slice）
	字典（map）
	通道（chan）
	结构体（struct）
	接口（interface）
PHP 并不支持指针类型，对于数组、切片、字典，PHP 则通过数组类型一网打尽，后面三个类型 PHP 也不支持，通道类型主要用于并发编程，
后面介绍 Go 语言并发编程的时候会详细讨论，结构体类似 PHP 中的类（class），Go 语言还把接口单独作为一个类型提出来，
后面介绍 Go 语言面向对象编程的时候会详细介绍这两个类型的使用。

4.1:布尔类型示例:
Go 语言中的布尔类型与 PHP 差不多，关键字为 bool，可赋值且只可以赋值为预定义常量 true 和 false。
示例代码如下:
	var v1 bool 
	v1 = true 
	或:
	v2 := (1 == 2) // v2 也会被推导为 bool 类型

与 PHP 不同的是，Go 是强类型语言，变量类型一旦确定，就不能将其他类型的值赋值给该变量。
因此，布尔类型不能接受其他类型的赋值，也不支持自动或强制的类型转换。
以下的示例是一些错误的用法，会导致编译错误:
	var b bool 
	b = 1 // 编译错误 
	b = bool(1) // 编译错误
PHP 中则支持类似的用法:
	$b = true;
	$b = 1;
	$b = (bool)1;
在 Go 语言中，以下的用法才是正确的:
	var b bool 
	b = (1!=0) // 编译正确 
	fmt.Println("Result:", b) // 打印结果为Result: true

此外，由于强类型的缘故，Go 语言在进行布尔值真假判断时，对值的类型有严格限制，在 PHP 这种弱类型语言中，
以下这些值在进行布尔值判断的时候（使用非严格的 == 比较符）都会被认为是 false:
	布尔值 FALSE 本身
	整型值 0（零）
	浮点型值 0.0（零）
	空字符串，以及字符串 "0"
	不包括任何元素的数组
	特殊类型 NULL（包括尚未赋值的变量）
	从空标记生成的 SimpleXML 对象

而在 Go 语言中则不然，甚至不同类型的值直接不能使用 == 或 != 运算符进行比较，在编译期就会报错，比如下面这段代码:
	b := (false == 0);
	报错信息:cannot convert 0 (type untyped number) to type bool
	invalid operation: false == 0 (mismatched types bool and int)

同样，! 运算符也不能作用于 非布尔 类型值。

4.2:整形
整型是所有编程语言里最基础的数据类型，Go 语言默认支持如下这些整型类型:

类型	长度（单位:字节）	说明	值范围															默认值
int8	1				带符号8位整型	-128~127													0
uint8	1				无符号8位整型，与 byte 类型等价	0~255									0
int16	2				带符号16位整型	-32768~32767											0
uint16	2				无符号16位整型	0~65535													0
int32	4				带符号32位整型，与 rune 类型等价	-2147483648~2147483647					0
uint32	4				无符号32位整型	0~4294967295											0
int64	8				带符号64位整型	-9223372036854775808~9223372036854775807				0
uint64	8				无符号64位整型	0~18446744073709551615									0
int		32位或64位		与具体平台相关	与具体平台相关											0
uint	32位或64位		与具体平台相关	与具体平台相关											0
uintptr	与对应指针相同	无符号整型，足以存储指针值的未解释位	32位平台下为4字节，64位平台下为8字节

Go 支持的整型类型要丰富的多，你可以根据需要设置合适的整型类型，以节省内存空间，
此外 int 和 int32 在 Go 语言里被认为是两种不同的类型（同理，int 和 int64 也是不同的类型），编译器也不会帮你自动做类型转换，
比如以下的例子会有编译错误:
	var int_value_1 int8
	int_value_2 := 8   // int_value_2 将会被自动推导为 int 类型 
	int_value_1 = int_value_2  // 编译错误
	错误信息:cannot use int_value_2 (type int) as type int8 in assignment
	int_value_1 = int8(int_value_2)) // 编译通过，（强制类型转换）

4.3:运算符
4.3.1:算术运算符
四则运算:+、-、*、/ 和 %（取余运算只能用于整数），不过由于强类型的关系，
在 Go 语言中，不同类型的整型值不能直接进行算术运算，比如下面这样计算就会报编译错误:
	int_value_3 := int_value_1 + int_value_2
编译错误信息如下:
	invalid operation: int_value_1 + int_value_2 (mismatched types int8 and int)
类型转化之后就好了:
	int_value_3 := int_value_1 + int8(int_value_2)

自增/自减运算符:即 ++/--，但是只能作为语句，不能作为表达式，且只能用作后缀，不能放到变量前面:
	int_value_1++  // 有效，int_value_1 的值变成 9
	int_value_1 = int_value_1++ // 无效，编译报错
	--int_value_1  // 无效，编译报错

也支持+=、-=、*=、/=、%= 这种快捷写法:
	int_value_1 += int_value_1 // 18
	int_value_1 -= int_value_1 // 0
	int_value_1 *= int_value_1 // 81
	int_value_1 /= int_value_1 // 1
	int_value_1 %= int_value_1 // 0
4.3.2:比较运算符
和 PHP 类似，Go 语言支持以下几种常见的比较运算符: >、<、==、>=、<= 和 !=，比较运算符运行的结果是布尔值。
不同类型的值不能放在一起比较，否则会报编译错处，相同类型的值才可以，
由此可见，所有比较运算符在比较的时候都会考虑进数据类型的因素，所以不需要类似 PHP 中 === 和 !== 这种严格比较运算符。

不过，各种类型的整型变量都可以直接与字面常量进行比较，
比如:
	if int_value_1 == 8 {
	    fmt.Println("int_value_1 = 8")
	}

4.3.3:位运算符
位运算符以二进制的方式对数值进行运算（效率更高），和 PHP 类似，Go 语言支持以下这几种位运算符:

运算符	含义	结果
x & y	按位与	把 x 和 y 都为 1 的位设为 1
x | y	按位或	把 x 或 y 为 1 的位设为 1
x ^ y	按位异或	把 x 和 y 一个为 1 一个为 0 的位设为 1
^x		按位取反	把 x 中为 0 的位设为 1，为 1 的位设为 0，PHP 中对应的位运算符是 ~，与 C 语言一致
x << y	左移	把 x 中的位向左移动 y 次，每次移动相当于乘以 2
x >> y	右移	把 x 中的位向右移动 y 次，每次移动相当于除以 2

4.3.4:逻辑运算符
与 PHP 类似，Go 语言也支持以下逻辑运算符::
运算符	含义	结果
x && y	逻辑与运算符（AND）	如果 x 和 y 都是 true，则结果为 true，否则结果为 false
x || y	逻辑或运算符（OR）	如果 x 或 y 是 true，则结果为 true，否则结果为 false
!x		逻辑非运算符（NOT）	如果 x 为 true，则结果为 false，否则结果为 true

4.3.5:运算符优先级
上面介绍的 Go 语言运算符的优先级如下所示（由上到下表示优先级从高到低，或者数字越大，优先级越高）:
	6      ^（按位取反） !
	5      *  /  %  <<  >>  &  &^
	4      +  -  |  ^（按位异或）
	3      ==  !=  <  <=  >  >=
	2      &&
	1      ||


4.4:浮点型
浮点型也叫浮点数，用于表示包含小数点的数据，比如 3.14、1.00 都是浮点型数据。

4.4.1:浮点数的表示:
和 PHP 一样，Go 语言中的浮点数采用IEEE-754 标准的表达方式，定义了两个类型:float32 和 float64，
其中 float32 等价于 PHP 的 float 类型（单精度浮点数），可以精确到小数点后 7 位，
float64 等价于 PHP 的 double 类型（双精度浮点数），可以精确到小数点后 15 位。

示例:
var float_value_1 float32
float_value_1 = 10  //
float_value_2 := 10.0 // 如果不加小数点，float_value_2 会被推导为整型而不是浮点型
float_value_3 := 1.1E-10

对于浮点类型需要被自动推导的变量，其类型将被自动设置为 float64，而不管赋值给它的数字是否是用 32 位长度表示的。
因此，对于以上的例子，下面的赋值将导致编译错误:
	float_value_1 = float_value_2  // float_value_2 是 float64 类型
	错误信息:cannot use float_value_2 (type float64) as type float32 in assignment
	float_value_1 = float32(float_value_2)//必须使用这样的强制类型转换才可以

在实际开发中，应该尽可能地使用 float64 类型，因为 math 包中所有有关数学运算的函数都会要求接收这个类型

4.4.2:浮点数的精度:
浮点数不是一种精确的表达方式，因为二进制无法精确表示所有十进制小数，比如 0.1、0.7 这种，
下面我们通过一个示例来给大家直观演示下:
	float_value_4 := 0.1
	float_value_5 := 0.7
	float_value_6 := float_value_4 + float_value_5
	注:浮点数的运算和整型一样，也要保证操作数的类型一致，float32 和 float64 类型数据不能混合运算，
	需要手动进行强制转化才可以，这一点和 PHP 不一样。

你觉得上面计算结果 float_value_6 的值是多少？0.8？不，它的结果是 0.7999999999999999，
这是因为计算机底层将十进制的 0.1 和 0.7 转化为二进制表示时，会丢失精度，
所以永远不要相信浮点数结果精确到了最后一位，也永远不要比较两个浮点数是否相等。

4.4.2:浮点数的比较:
浮点数支持通过算术运算符进行四则运算，也支持通过比较运算符进行比较（前提是运算符两边的操作数类型一致），
但是涉及到相等的比较除外，因为我们上面提到，看起来相等的两个十进制浮点数，在底层转化为二进制时会丢失精度，因此不能被表象蒙蔽。
如果一定要判断相等，下面是一种替代的解决方案:
	p := 0.00001
	// 判断 float_vlalue_1 与 float_value_2 是否相等
	if math.Dim(float64(float_value_1), float_value_2) < p {
	    fmt.Println("float_value_1 和 float_value_2 相等")
	}
可以看到，我们的解决方案是一种近似判断，通过一个可以接受的最小误差值 p，
约定如果两个浮点数的差值在此精度的误差范围之内，则判定这两个浮点数相等。
这个解决方案也是其他语言判断浮点数相等所采用的通用方案，PHP 也是这么做的。

4.5:复数类型:complex64~32位实部和虚部、complex128~64位实部和虚部
除了整型和浮点型之外，Go 语言还支持复数类型，与复数相对，我们可以把整型和浮点型这种日常比较常见的数字称为实数，
复数是实数的延伸，可以通过两个实数（在计算机中用浮点数表示）构成，一个表示实部（real），一个表示虚部（imag），
常见的表达形式如下:z = a + bi
其中 a、b 均为实数，i 称为虚数单位，当 b = 0 时，z 就是常见的实数，当 a = 0 而 b ≠ 0 时，将 z 称之为纯虚数，
如果你理解数学概念中的复数概念，这些都很好理解，
	var complex_value_1 complex64        
	complex_value_1 = 1.10 + 10i          // 由两个 float32 实数构成的复数类型
	complex_value_2 := 1.10 + 10i         // 和浮点型一样，默认自动推导的实数类型是 float64，所以 complex_value_2 是 complex128 类型
	complex_value_3 := complex(1.10, 10)  // 与 complex_value_2 等价
	对于一个复数 z = complex(x, y)，就可以通过 Go 语言内置函数 real(z) 获得该复数的实部，也就是 x，通过 imag(z) 获得该复数的虚部，也就是 y。

4.6:字符串
在 Go 语言中，字符串是一种基本类型，默认是通过 UTF-8 编码的字符序列，当字符为 ASCII 码时则占用 1 个字节，
其它字符根据需要占用 2-4 个字节，比如中文编码通常需要 3 个字节。

4.6.1:声明和初始化:
	var str string         // 声明字符串变量
	str = "Hello World"    // 变量初始化
	str_2 := "你好，学院君"   // 也可以同时进行声明和初始化

4.6.2:获取指定单个字符:可以通过访问数组下标的方式
	ch := str[0] // 取字符串的第一个字符

4.6.3:格式化输出
还可以通过 Go 语言内置的 len() 函数获取指定字符串的长度，以及通过 fmt 包提供的 Printf 进行字符串格式化输出（用法和 PHP 中的 printf 类似）:
	fmt.Printf("The length of \"%s\" is %d \n", str, len(str)) //The length of "Hello world" is 11
	fmt.Printf("The first character of \"%s\" is %c.\n", str, ch)//The first character of "Hello world" is H.

4.6.4:转义字符
与 PHP 不同，Go 语言的字符串不支持单引号，只能通过双引号定义字符串字面值，如果要对特定字符进行转义，
可以通过 \ 实现，就像我们上面在字符串中转义双引号和换行符那样，常见的需要转义的字符如下所示:
	\n :换行符
	\r :回车符
	\t :tab 键
	\u 或 \U :Unicode 字符
	\\ :反斜杠自身
	所以，上述打印代码输出结果为:
	The length of "Hello world" is 11 
	The first character of "Hello world" is H.

4.6.5:不可变值类型
虽然可以通过数组下标方式访问字符串中的字符，但是和数组不同，在 Go 语言中，字符串是一种不可变值类型，
一旦初始化之后，它的内容不能被修改，比如看下面这个例子:
	str := "Hello world"
	str[0] = 'X' // 编译错误,cannot assign to str[0]

4.6.6:字符串操作

4.6.6.1:字符串连接:
PHP 默认提供了丰富的字符串函数对字符串进行操作，Go 也不例外，常见的操作包含连接、获取长度和指定字符，
获取长度和指定字符前面已经介绍过，字符串连接只需要通过「+」即可:
	str = str + ", 学院君"
	str += ", 学院君"  // 上述语句也可以简写为这样，效果完全一样
另外，还有一点需要注意的是如果字符串长度较长，需要换行，则「+」必须出现在上一行的末尾，否则会报错:
str = str +
        ", 学院君"

4.6.6.2:字符串切片:
字符串切片和 PHP 的 substr 函数使用方式有所差异，通过「:」对字符串进行切片，冒号之前的数字代表起始点（为空表示从0开始），
之后的数字代表结束点（为空表示到字符串最后），而不是子串的长度。
	str = "hello, world"
	str_1 := str[:5]  // 获取索引5（不含）之前的子串
	str_2 := str[7:]  // 获取索引7（含）之后的子串
	str_3 := str[0:5]  // 获取从索引0（含）到索引5（不含）之间的子串
	fmt.Println(str_1)//hello
	fmt.Println(str_2)//world
	fmt.Println(str_3)//hello
此外 Go 字符串也支持字符串比较、是否包含指定字符/子串、获取指定子串索引位置、字符串替换、大小写转换、trim 等操作，更多操作 API，请参考标准库 strings 包。

4.6.7:字符串遍历:
Go 语言支持两种方式遍历字符串。

一种是以字节数组的方式遍历:
str := "Hello, 世界" 
n := len(str) 
for i := 0; i < n; i++ {
    ch := str[i]    // 依据下标取字符串中的字符，类型为byte
    fmt.Println(i, ch) 
}
结果:
0 72 
1 101 
2 108 
3 108 
4 111 
5 44 
6 32 
7 228 
8 184 
9 150 
10 231 
11 149 
12 140
可以看出，这个字符串长度为 13，尽管从直观上来说，这个字符串应该只有 9 个字符。
这是因为每个中文字符在 UTF-8 中占 3 个字节，而不是 1 个字节。

另一种是以 Unicode 字符遍历:
str := "Hello, 世界" 
for i, ch := range str { 
    fmt.Println(i, ch)    // ch 的类型为 rune 
}
结果:
0 72 
1 101 
2 108 
3 108 
4 111 
5 44 
6 32 
7 19990 
10 30028
这个时候，打印的就是 9 个字符了，以 Unicode 字符方式遍历时，每个字符的类型是 rune（早期的 Go 语言用 int 类型表示 Unicode 字符），而不是 byte。

4.7:基本数据类型之间的转化
通过前面几篇教程，我们已经陆续介绍完了 Go 语言中的基本数据类型，分别是布尔类型、整型、浮点型、复数类型、字符串和字符类型，
和 PHP 一样，Go 语言也支持这些基本数据类型之间的转化，但是不是像 PHP 那种可以自动转化，
由于 Go 语言是强类型语言，所以类似PHP的自动转化操作是不允许的，必须要对变量进行强制类型转化才能通过运算符进行计算，
下面，我们来看看在 Go 语言中如何实现不同数据类型之间的强制转化。
4.7.1:整形的转换:
v1 := uint(16)   // 初始化 v1 类型为 unit
v2 := int8(v1)   // 将 v1 转化为 int8 类型并赋值给 v2
v3 := uint16(v2) // 将 v2 转化为 uint16 类型并赋值给 v3

看起来很简单，不过需要注意，在有符号与无符号以及高位数字向低位数字转化时，需要注意数字的溢出和截断，
比如我们看这个例子:
v1 := uint(-255)//由于 uint 是无符号整型，所以上述转化编译时会报错:constant -255 overflows uint

我们将上述代码改造如下:
v1 := uint(255)
v2 := int8(v1)  // v2 = -1
由于 int8 能够表示的范围是 -128~127，255 超出其表示范围，所以，会截取后8位，v1 是一个无符号整型，后八位都是 1，int8 是一个有符号的整型，
所以最高位作为符号位，因此转化后的数字 v2 是负数，11111111 是这个负数的补码，它的原码是 10000001
（原码=补码的补码，正数的补码是自身，负数的补码是反码+1，具体可参考计算机基础理论中原码、反码、补码的概念），所以 v2 最终转化后的结果是 -1。

4.7.2:整型和浮点型之间的转化
浮点型转化为整型时，小数位被丢弃:
v1 := 99.99
v2 := int(v1)  // v2 = 99
将整型转化为浮点型时，比较简单，直接调用对应的函数即可
v1 := 99
v2 := float64(v2)

4.7.3:数值和布尔类型之间的转化
目前 Go 语言不支持将数值类型转化为布尔型，你需要自己根据需求去实现类似的转化。

4.7.4:字符串和其他基本类型之间的转化
与 PHP 不同的是，Go 语言不支持将字符串类型强制转化为数值类型(但是可以通过strconv 包实现)。
整型数据可以通过对应的 UTF-8 编码转化为对应的字符串:
v1 := 65
v2 := string(v1)  // v2 = A

v3 := 30028
v4 := string(v3)  // v4 = 界

此外还可以将字节数组或者 rune（Unicode 编码字符）数组转化为字符串:
v1 := []byte{'h', 'e', 'l', 'l', 'o'}
v2 := string(v1)  // v2 = hello

v3 := []rune{0x5b66, 0x9662, 0x541b}
v4 := string(v3)  // v4 = 学院君

4.7.5:strconv 包
要实现类似 PHP 中字符串与其他基本数据类型之间的转化，可以通过 strconv 这个包提供的函数来实现:
	v1 := "100"
	v2, err := strconv.Atoi(v1)  // 将字符串转化为整型，v2 = 100

	v3 := 100
	v4 := strconv.Itoa(v3)   // 将整型转化为字符串, v4 = "100"

	v5 := "true"
	v6, err := strconv.ParseBool(v5)  // 将字符串转化为布尔型
	v5 = strconv.FormatBool(v6)  // 将布尔值转化为字符串

	v7 := "100"
	v8, err := strconv.ParseInt(v7, 10, 64)   // 将字符串转化为整型，第二个参数表示几进制，第三个参数表示最大位数
	v7 = strconv.FormatInt(v8, 10)   // 将整型转化为字符串，第二个参数表示几进制

	v9, err := strconv.ParseUint(v7, 10, 64)   // 将字符串转化为无符号整型，参数含义同 ParseInt
	v7 = strconv.FormatUint(v9, 10)  // 将字符串转化为无符号整型，参数含义同 FormatInt

	v10 := "99.99"
	v11, err := strconv.ParseFloat(v10, 64)   // 将字符串转化为浮点型，第二个参数表示精度
	v10 = strconv.FormatFloat(v11, 'E', -1, 64)

	q := strconv.Quote("Hello, 世界")    // 为字符串加引号
	q = strconv.QuoteToASCII("Hello, 世界")  // 将字符串转化为 ASCII 编码

4.8:数组
数组的声明和初始化
数组是所有语言编程中最常用的数据结构之一，Go 语言也不例外，与 PHP、JavaScript 等弱类型动态语言不同，
在 Go 语言中，数组是固定长度的、同一类型的数据集合。数组中包含的每个数据项被称为数组元素，一个数组包含的元素个数被称为数组的长度。

和 PHP 一样，Go 语言也通过 [] 来标识数组类型，以下是一些常见的数组声明方法:
var a [8]byte // 长度为8的数组，每个元素为一个字节
var b [3][3]int // 二维数组（9宫格）
var c [3][3][3]float64 // 三维数组（立体的9宫格）
var d = [3]int{1, 2, 3}  // 声明时初始化
var e = new([3]string)   // 通过 new 初始化
从以上示例可以看出，数组也可以是多维的，与 PHP 不同的是，Go 语言中数组元素必须是同一个数据类型，
并且需要在声明的时候指定元素类型和数组长度（静态语言的特征）。
还可以通过 := 对数组进行声明和初始化:
a := [5]int{1,2,3,4,5}

此外，还可以通过这种语法糖省略数组长度的声明:
a := [...]int{1, 2, 3}//这种情况下，Go 会在编译期自动计算出数组长度（3）。

数组在初始化的时候，如果没有填满，则空位会通过对应的元素类型空值填充:
a := [5]int{1, 2, 3}
fmt.Println(a)//[1 2 3 0 0]

此外，我们还可以初始化指定下标位置的元素值:
a := [5]int{1: 3, 3: 7}//[0 3 0 7 0]

数组长度在定义后就不可更改，在声明时可以指定数组长度为一个常量或者一个常量表达式
（常量表达式是指在编译期即可计算结果的表达式）。数组的长度是该数组类型的一个内置常量，可以用 Go 语言的内置函数 len() 来获取:
arrLength := len(arr)

PHP 数组非常强大，囊括了常规的数组（Array）、集合（Set）、列表（List）、字典（Map）等数据结构，
Go 语言的数组和大多数其他静态语言的数组一样，索引只能是数字，在 PHP 中，我们把索引是数字的数组叫做索引数组，
把索引包含字符串的数组叫做关联数组，所以 Go 语言中的数组可以对照 PHP 中的索引数组来理解，不能是那种包含字符串键值对的关联数组。

4.8.1:访问数组元素
和 PHP 索引数组一样，可以使用数组下标来访问 Go 语言数组中的元素，数组下标默认从 0 开始，len(arr)-1 表示最后一个元素的下标:
arr := [5]int{1,2,3,4,5}
a1, a2 := arr[0], arr[len(arr) - 1]
上面 a1 的值是 1，a2 的值是 5。
访问数组元素时，下标必须在有效范围内，比如对于一个长度为 5 的数组，下标有效范围是 0~4，超出这个范围编译时会报索引越界异常。

4.8.2:遍历数组
我们还可以通过一个 for 循环遍历所有数组元素:
	for i := 0; i < len(arr); i++ {
	    fmt.Println("Element", i, "of arr is", arr[i])
	}

Go 语言还提供了一个关键字 range，用于快速遍历数组中的元素:
for i, v := range arr { 
    fmt.Println("Element", i, "of arr is", v) 
}
range 表达式返回两个值，第一个是数组下标索引值，第二个是索引对应数组元素值，这种用法和 PHP 中的 foreach 语法类似:

如果我们不想获取索引值，可以这么做:
for _, v := range arr {
   // ...
}

如果只想获取索引值，可以这么做:
for i := range arr {
   // ...
}

4.8.3:设置数组元素
和字符串这种不可变值类型不一样，数组除了支持通过下标访问对应索引的元素值之外，还可以通过下标设置对应索引位置的元素值:
arr[0] = 100

4.9:数组切片
我们已经介绍过数组的一个特点:数组的长度在定义之后无法修改，数组长度是数组类型本身的一部分，是数组的一个内置常量，
因此我们无法在数组上做动态的元素增删操作。显然这种数据结构无法完全满足开发者的日常开发需求，
尤其是从 PHP 转过来的开发人员（PHP 的数组非常灵活和强大），为此，Go 语言提供了数组切片（slice）来弥补数组的不足，
数组切片一个最强大的功能就是支持对元素做动态增删操作，在介绍动态增删元素之前，我们先来了解下数组切片的定义和创建。

4.9.1:数组切片的定义
在 Go 语言中，数组切片是一个新的数据类型，与数组最大的不同在于，切片的类型字面量中只有元素的类型，没有长度:
var slice []string = []string{"a", "b", "c"}
因此它是一个可变长度的、同一类型元素集合，切片的长度可以随着元素数量的增长而增长（不会随着元素数量的减少而减少），
不过数组切片从底层管理上来看依然使用数组来管理元素，可以看作是对数组做了一层简单的封装。
基于数组，数组切片添加了一系列管理功能，可以随时动态扩充存储空间，下面我们就来看看数组切片的创建和使用。

4.9.2:创建数组切片
创建数组切片的方法主要有三种 —— 基于数组、数组切片和直接创建，下面我们来简要介绍一下这几种方法。

4.9.2.1:基于数组
数组切片可以基于一个已存在的数组创建。从这个层面来说，数组可以看作是切片的底层数组，而切片则可以看作是数组某个连续片段的引用。
数组切片可以只使用数组的一部分元素或者整个数组来创建，甚至可以创建一个比所基于的数组还要大的数组切片:
// 先定义一个数组
months := [...]string{"January", "February", "March", "April", "May", "June",
                      "July", "August", "September", "October", "November", "December"}

// 基于数组创建数组切片
q2 := months[3:6]    // 第二季度
summer := months[5:8]  // 夏季

fmt.Println(q2)//[April May June]
fmt.Println(summer)//[June July August]
Go 语言支持通过 array[first:last] 这样的方式来基于数组生成一个数组切片，而且这个用法还很灵活，
比如下面几种用法都是合法的:

基于 months 的所有元素创建数组切片（全年）:
all := months[:]

基于 months 的前 6 个元素创建数组切片（上半年）:
firsthalf := months[:6]

基于从第 6 个元素开始的所有元素创建数组切片（下半年）:
secondhalf := months[6:]

另外，通过这个示例，还可以探讨下数组切片底层的结构，数组切片底层引用了一个数组，由三个部分构成:指针、长度和容量，指针指向数组起始下标，
长度对应切片中元素的个数，容量则是切片起始位置到底层数组结尾的位置，切片长度不能超过容量，比如上面的数组切片 q2，
其指针指向底层数组 months 下标为 3 的位置，切片长度是3，切片容量是9（从下标3开始到下标11结束，可容纳9个元素），
和数组一样，我们可以通过内置函数 len 和 cap 来分别获取数组切片的长度和容量:
fmt.Println(len(q2))   // 3
fmt.Println(cap(q2))   // 9

4.9.2.2:基于数组切片
类似于数组切片可以基于一个数组创建，数组切片也可以基于另一个数组切片创建:
firsthalf := months[:6]
q1 := firsthalf[:3] // 基于firsthalf的前3个元素构建新数组切片

基于 firsthalf 创建数组切片时，选择的 firsthalf 元素范围可以超过所包含的元素个数，比如 q1 可以基于firsthalf 的前 9 个元素创建:
q1 := firsthalf[:9]
打印结果是:[January February March April May June July August September]。
因为 firsthalf 的容量是 12，只要选择的范围不超过 firsthalf 的容量，那么这个创建操作就是合法的。

4.9.2.3:直接创建
并非一定要事先准备一个数组才能创建数组切片，Go 语言提供的内置函数 make() 可以用于灵活地创建数组切片。
下面的例子示范了直接创建数组切片的各种方法:

mySlice1 := make([]int, 5)// 创建一个初始元素个数为 5 的数组切片，元素类型为整型，初始值为 [0 0 0 0 0]，容量为 5
mySlice2 := make([]int, 5, 10)//创建一个初始元素个数为 5 的整型数组切片，初始值为 [0 0 0 0 0]，并预留 10 个元素的存储空间（容量为10）
mySlice3 := []int{1, 2, 3, 4, 5}//此外，还可以直接创建并初始化包含 5 个元素的数组切片:

4.9.3:遍历数组切片
操作数组元素的所有方法都适用于数组切片，比如数组切片也可以按下标读写元素，用 len() 函数获取元素个数，并支持使用 range 关键字来快速遍历所有元素。
传统的元素遍历方法如下:
for i := 0; i < len(summer); i++ {
    fmt.Println("summer[", i, "] =", summer[i]) 
}

使用 range 关键字可以让遍历代码显得更简洁，range 表达式有两个返回值，第一个是索引，第二个是元素的值:
for i, v := range summer { 
    fmt.Println("summer[", i, "] =", v) 
}

4.9.3:在数组切片中动态增加元素
切片比数组更强大之处在于支持动态增加元素，甚至可以在容量不足的情况下自动扩容，
在切片类型中，元素个数和实际可分配的存储空间是两个不同的值，元素的个数即切片的实际长度，而可分配的存储空间就是切片的容量。

一个切片的容量初始值根据创建方式的不同而不同:
对于基于数组和切片创建的切片而言，默认容量是从切片起始索引到对应底层数组的结尾索引；
对于通过内置 make 函数创建的切片而言，在没有指定容量参数的情况下，默认容量和切片长度一致。

所以，通常一个切片的长度值小于等于其容量值，我们可以通过 Go 语言内置的 cap() 函数和 len() 函数来获取某个切片的容量和实际长度:
var oldSlice = make([]int, 5, 10)
fmt.Println("len(oldSlice):", len(oldSlice))//len(oldSlice): 5
fmt.Println("cap(oldSlice):", cap(oldSlice))//cap(oldSlice): 10

此时，切片 oldSlice 的默认值是 [0 0 0 0 0]，我们可以通过 append() 函数向切片追加新元素:
newSlice := append(oldSlice, 1, 2, 3)
将返回的新切片赋值给 newSlice，此时 newSlice 的长度是 8，容量是 10，切片值是:
[0 0 0 0 0 1 2 3]

函数 append() 的第二个参数是一个不定参数，我们可以按自己需求添加若干个元素（大于等于1个），甚至直接将一个数组切片追加到另一个数组切片的末尾:
appendSlice := []int{1, 2, 3, 4, 5}
newSlice := append(oldSlice, appendSlice...)  // 注意末尾的 ... 不能省略

如果追加的元素个数超出 oldSlice 的默认容量，则底层会自动进行扩容:
newSlice := append(oldSlice, 1, 2, 3, 4, 5, 6)
fmt.Println(newSlice)
fmt.Println(len(newSlice))
fmt.Println(cap(newSlice))

此时 newSlice 的长度变成了 11，容量变成了 20，需要注意的是 append() 函数并不会改变原来的切片，而是会生成一个容量更大的切片，
然后把原有的元素和新元素一并拷贝到新切片中，默认情况下，扩容后新切片的容量将会是原切片容量的 2 倍，如果还不足以容纳新元素，则按照同样的操作继续扩容
，直到新容量不小于原长度与要追加的元素数量之和。但是，当原切片的长度大于或等于 1024 时，Go 语言将会以原容量的 1.25 倍作为新容量的基准。

因此，如果实现能预估切片的容量并在初始化时合理地设置容量值，可以大幅降低切片内部重新分配内存和搬送内存块的操作次数，从而提高程序性能。

4.9.4:内容复制
切片类型还支持 Go 语言的另一个内置函数 copy()，用于将元素从一个数组切片复制到另一个数组切片。如果加入的两个数组切片不一样大，
就会按其中较小的那个数组切片的元素个数进行复制。下面的示例展示了 copy() 函数的行为:
slice1 := []int{1, 2, 3, 4, 5} 
slice2 := []int{5, 4, 3}

// 复制 slice1 到 slice 2
copy(slice2, slice1) // 只会复制 slice1 的前3个元素到 slice2 中
// 复制 slice2 到 slice 1
copy(slice1, slice2) // 只会复制 slice2 的 3 个元素到 slice1 的前 3 个位置

4.9.5:动态删除元素
切片除了支持动态增加元素之外，还可以动态删除元素，在切片中动态删除元素可以通过多种方式实现（其实是通过切片实现的「伪删除」）:
slice3 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
slice3 = slice3[:len(slice3) - 5]  // 删除 slice3 尾部5个元素
slice3 = slice3[5:]  // 删除 slice3 头部 5 个元素
此时切片 slice3 的所有元素被删除，长度是0，容量也变成 5，注意这里不是自动缩容，而是第二个切片容量计算逻辑决定的。

此外，还可以通过上述介绍的 append 函数和 copy 函数实现切片元素的「删除」:
slice3 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

slice4 := append(slice3[:0], slice3[3:]...)  // 删除开头三个元素
slice5 := append(slice3[:1], slice3[4:]...)  // 删除中间三个元素
slice6 := append(slice3[:0], slice3[:7]...)  // 删除最后三个元素

slice7 := slice3[:copy(slice3, slice3[3:])]  // 删除开头前三个元素
append 相对好理解一些，copy 之所以可以用于删除元素，是因为其返回值是拷贝成功的元素个数，
我们可以根据这个值完成新切片的设置从而达到「删除」元素的效果。
和动态增加元素一样，原切片的值并没有变动，而是创建出一个新的内存空间来存放新切片并将其赋值给其它变量

4.10:字典
有 PHP 基础的同学都应该知道，PHP 数组包含索引数组和关联数组，PHP 中的索引数组即对应 Go 语言的数组和切片类型，
PHP 中的关联数组即对应 Go 语言中的字典类型（map），所谓字典，其实就是存储键值对映射关系的集合，只不过对于强类型的 Go 语言来说，
与 PHP 关联数组的不同之处在于需要在声明时指定键和值的类型，此外 Go 字典是个无序集合，底层不会像 PHP 那样按照元素添加顺序维护元素的存储顺序。


如果一个接口的方法集合是某个类方法集合的子集，我们就认为该类实现了这个接口。
