<?php

windows office转pdf 类
class PDFConverter
{
    private $com;

    /**
     * need to install openoffice and run in the background
     * soffice -headless-accept="socket,host=127.0.0.1,port=8100;urp;" -nofirststartwizard
     */
    public function __construct()
    {
        try {
            $this->com = new COM('com.sun.star.ServiceManager');
        } catch (Exception $e) {
            die('Please be sure that OpenOffice.org is installed.');
        }
    }

    /**
     * Execute PDF file(absolute path) conversion
     * @param $source [source file]
     * @param $export [export file]
     */
    public function execute($source, $export)
    {
        $source = 'file:///' . str_replace('\\', '/', $source);
        $export = 'file:///' . str_replace('\\', '/', $export);
        $this->convertProcess($source, $export);
    }

    /**
     * Get the PDF pages
     * @param $pdf_path [absolute path]
     * @return int
     */
    public function getPages($pdf_path)
    {
        if (!file_exists($pdf_path)) return 0;
        if (!is_readable($pdf_path)) return 0;
        if ($fp = fopen($pdf_path, 'r')) {
            $page = 0;
            while (!feof($fp)) {
                $line = fgets($fp, 255);
                if (preg_match('/\/Count [0-9]+/', $line, $matches)) {
                    preg_match('/[0-9]+/', $matches[0], $matches2);
                    $page = ($page < $matches2[0]) ? $matches2[0] : $page;
                }
            }
            fclose($fp);
            return $page;
        }
        return 0;
    }

    private function setProperty($name, $value)
    {
        $struct = $this->com->Bridge_GetStruct('com.sun.star.beans.PropertyValue');
        $struct->Name = $name;
        $struct->Value = $value;
        return $struct;
    }

    private function convertProcess($source, $export)
    {
        $desktop_args = array($this->setProperty('Hidden', true));
        $desktop = $this->com->createInstance('com.sun.star.frame.Desktop');
        $export_args = array($this->setProperty('FilterName', 'writer_pdf_Export'));
        $program = $desktop->loadComponentFromURL($source, '_blank', 0, $desktop_args);
        $program->storeToURL($export, $export_args);
        $program->close(true);
    }
}


PDF转office的具体使用
// use App\Http\Controller;
// use Illuminate\Http\Request;
// use Illuminate\Support\Facades\Storage;
// use PDFConverter;
class UploadController 
{

     /*windows本地@2019-3-4重写(com实现)*/
    public function tranOffice(Request $request)
    {
        //允许上传的文件格式
        $allow_ext=['pdf','doc','docx','xls','xlsx','ppt','pptx'];
        if ($request->isMethod('post')) {

            //接收上传文件
            $input_file = $request->file('clientfile');
            //上传文件存储目录
            $type = $request->type;//存储文件目录
            //文件后缀
            $filetype = strtolower($input_file->getClientOriginalExtension());
            //判断上传文件格式
            if(!in_array($filetype,$allow_ext)){
                return response()->json(["上传的文件格式必须是 'pdf','doc','docx','xls','xlsx','ppt','pptx' 格式类型"], 422);
            }
            //判断上传文件大小
            if (($input_file->getClientSize() / 1024 / 1024) > 400) {
                return response()->json(["上传的文件大于 400 M, 请压缩之后上传"], 422);
            }
            // 第一个参数代表目录, 第二个参数代表我上方自己定义的一个存储媒介
            //$path = $input_file->store($type, 'uploads');
            $path = $input_file->store('gonggong', 'local');
            //die();
            //gonggong/W0rjN0c5C94yp5unSF2RZxiCv1EneH6DiP2k67zQ.docx
            //2019-3-1
            $file_name=substr(strrchr($path,'/'),1);
            //W0rjN0c5C94yp5unSF2RZxiCv1EneH6DiP2k67zQ.docx
            $file_name_name=substr(strchr($path,'.',true),0);
            //gonggong/W0rjN0c5C94yp5unSF2RZxiCv1EneH6DiP2k67zQ
            if (in_array($filetype, ['pdf'])) {
                $upload_path = public_path() . '/uploads/';
                $upload_path=str_replace('\\','/',$upload_path);
                $source=$upload_path.$path;
                Storage::move($path,$type.'/'.$file_name);
                //$imgfiles = pdf2img($source);//调用转图片公共函数
                return response()->json([
                    'msg'      => $type.'/'.$file_name,
                    //'imgfiles' => $imgfiles,
                    'imgfiles' => []
                ]);
                die();
            }

            //word/excle只转PDF不转图片
            if (in_array($filetype, [
                'doc', 'docx','xls', 'xlsx'
            ])) {
                $upload_path = public_path() . '/uploads/';
                $upload_path=str_replace('\\','/',$upload_path);
                $converter = new PDFConverter();
                $source=$upload_path.$path;
                $export=$upload_path.$path.'.pdf';
                $converter->execute($source, $export);
                sleep(2);
                //移动office源文件和转为PDF后的文件到机构目录下
                Storage::move($path,$type.'/'.$file_name);
                Storage::move($path.'.pdf',$type.'/'.$file_name.'.pdf');
                //$imgfiles = pdf2img($source . '.pdf');
                sleep(2);
                return response()->json([
                    'msg'      => $type.'/'.$file_name. '.pdf',
                    //'imgfiles' => $imgfiles
                    'imgfiles' => []
                ]);
                die();
            }

            if (in_array($filetype, [
                'ppt', 'pptx',
            ])) {
                $upload_path = public_path() . '/uploads/';
                $upload_path=str_replace('\\','/',$upload_path);
                $converter = new PDFConverter();
                $source=$upload_path.$path;
                $export=$upload_path.$path.'.pdf';
                $converter->execute($source, $export);
                $imgfiles = pdf2img($source . '.pdf');
                sleep(2);
                //移动office源文件和转为PDF后的文件到机构目录下
                Storage::move($path,$type.'/'.$file_name);
                Storage::move($path.'.pdf',$type.'/'.$file_name.'.pdf');
                $all_images=Storage::files($file_name_name);
                foreach ($all_images as $v){
                    $aaa=substr(strchr($v,'/'),0);
                    Storage::move($v,$type.$aaa);
                }
                //删除移动图片后的图片空目录
                Storage::deleteDirectory($file_name_name);
                sleep(2);
                return response()->json([
                    'msg'      => $type.'/'.$file_name . '.pdf',
                    'imgfiles' => $imgfiles
                ]);
                die();
            }

            return response()->json(['msg' => $filetype . '这个文件类型转换还在开发中！']);
        }
    }

    /*windows本地@jodconverter.jar实现*/
    public function tranOffice111(Request $request)
    {

        if ($request->isMethod('post')) {
            $input_file = $request->file('clientfile');
            $type = $request->type;
            //文件后缀
            $filetype = strtolower($input_file->getClientOriginalExtension());
            //允许上传的文件格式
            $allow_ext=['pdf','doc','docx','xls','xlsx','ppt','pptx'];
            //判断上传文件格式
            if(!in_array($filetype,$allow_ext)){
                return response()->json(["上传的文件格式必须是 'pdf','doc','docx','xls','xlsx','ppt','pptx' 格式类型"], 422);
            }
            //判断上传文件大小
            if (($input_file->getClientSize() / 1024 / 1024) > 400) {
                return response()->json(["上传的文件大于 400 M, 请压缩之后上传"], 422);
            }
            // 第一个参数代表目录, 第二个参数代表我上方自己定义的一个存储媒介
            //$path = $input_file->store($type, 'uploads');
            $path = $input_file->store('gonggong', 'uploads');
            //gonggong/W0rjN0c5C94yp5unSF2RZxiCv1EneH6DiP2k67zQ.docx
            //2019-3-1
            $file_name=substr(strrchr($path,'/'),1);


            if (in_array($filetype, ['pdf'])) {
                $upload_path = public_path() . '/uploads/';
                $upload_path=str_replace('\\','/',$upload_path);
                Storage::move($path,$type.'/'.$file_name);
                $imgfiles = pdf2img($upload_path.$type.'/'.$file_name);
                return response()->json(['msg'=> $type.'/'.$file_name, 'imgfiles' => $imgfiles]);
            }

            if (in_array($filetype, ['ppt', 'pptx'])) {
                $upload_path = public_path() . '/uploads/';
                $upload_path=str_replace('\\','/',$upload_path);
                $input_file = $upload_path . $path;
                $out_file = $input_file . '.pdf';
                $file = "java -jar " . $upload_path . "office2pdf/jodconverter-2.2.2/lib/jodconverter-cli-2.2.2.jar " . $input_file . " " . $out_file;
                exec($file);
                Storage::move($path,$type.'/'.$file_name);
                Storage::move($path.'.pdf',$type.'/'.$file_name.'.pdf');
                $imgfiles = pdf2img($upload_path.$type.'/'.$file_name.'.pdf');
                return response()->json(['msg' => $path.'.pdf', 'imgfiles' => $imgfiles]);
            }

            if (in_array($filetype, ['docx', 'doc','xls','xlsx'])) {
                $upload_path = public_path() . '/uploads/';
                $upload_path=str_replace('\\','/',$upload_path);
                $input_file = $upload_path . $path;
                $out_file = $input_file . '.pdf';
                $file = "java -jar " . $upload_path . "office2pdf/jodconverter-2.2.2/lib/jodconverter-cli-2.2.2.jar " . $input_file . " " . $out_file;
                exec($file);
                Storage::move($path,$type.'/'.$file_name);
                Storage::move($path.'.pdf',$type.'/'.$file_name.'.pdf');
                //$imgfiles = pdf2img($upload_path.$type.'/'.$file_name.'.pdf');
                //return response()->json(['msg' => $path . '.pdf', 'imgfiles' => $imgfiles]);
                return response()->json(['msg' => $path . '.pdf']);
            }

        }
    }

    /*linux-线上@jodconverter.jar实现*/
    public function tranOffice_online(Request $request)
    {

        if ($request->isMethod('post')) {
            $input_file = $request->file('clientfile');
            $type = $request->type;
            //文件后缀
            $filetype = strtolower($input_file->getClientOriginalExtension());
            //允许上传的文件格式
            $allow_ext=['pdf','doc','docx','xls','xlsx','ppt','pptx'];
            //判断上传文件格式
            if(!in_array($filetype,$allow_ext)){
                return response()->json(["上传的文件格式必须是 'pdf','doc','docx','xls','xlsx','ppt','pptx' 格式类型"], 422);
            }
            //判断上传文件大小
            if (($input_file->getClientSize() / 1024 / 1024) > 400) {
                return response()->json(["上传的文件大于 400 M, 请压缩之后上传"], 422);
            }
            // 第一个参数代表目录, 第二个参数代表我上方自己定义的一个存储媒介
            //$path = $input_file->store($type, 'uploads');
            $path = $input_file->store('gonggong', 'uploads');
            //gonggong/W0rjN0c5C94yp5unSF2RZxiCv1EneH6DiP2k67zQ.docx
            //2019-3-1
            $file_name=substr(strrchr($path,'/'),1);


            if (in_array($filetype, ['pdf'])) {
                $upload_path = public_path() . '/uploads/';
                $upload_path=str_replace('\\','/',$upload_path);
                Storage::move($path,$type.'/'.$file_name);
                //$imgfiles = pdf2img($upload_path.$type.'/'.$file_name);
                return response()->json(['msg'=> $type.'/'.$file_name, ]);
            }

            if (in_array($filetype, ['ppt', 'pptx'])) {
                $upload_path = public_path() . '/uploads/';
                $upload_path=str_replace('\\','/',$upload_path);
                $input_file = $upload_path . $path;
                $out_file = $input_file . '.pdf';
                //$file = "java -jar " . $upload_path . "office2pdf/jodconverter-2.2.2/lib/jodconverter-cli-2.2.2.jar " . $input_file . " " . $out_file;
                $file = "/home/java/jdk1.8.0_202/bin/java -jar " . $upload_path . "office2pdf/jodconverter-2.2.2/lib/jodconverter-cli-2.2.2.jar " . $input_file . " " . $out_file;
                exec($file);
                Storage::move($path,$type.'/'.$file_name);
                Storage::move($path.'.pdf',$type.'/'.$file_name.'.pdf');
                $imgfiles = pdf2img($upload_path.$type.'/'.$file_name.'.pdf');
                // return response()->json(['msg' => $path.'.pdf', 'imgfiles' => $imgfiles]);
                return response()->json(['msg' => $type.'/'.$file_name. '.pdf', 'imgfiles' => $imgfiles]);
            }


            if (in_array($filetype, ['docx', 'doc','xls','xlsx'])) {
                $upload_path = public_path() . '/uploads/';
                $upload_path=str_replace('\\','/',$upload_path);
                $input_file = $upload_path . $path;
                $out_file = $input_file . '.pdf';
                //return $input_file;
                //$file = "java -jar " . $upload_path . "office2pdf/jodconverter-2.2.2/lib/jodconverter-cli-2.2.2.jar " . $input_file . " " . $out_file;
                $file = "/home/java/jdk1.8.0_202/bin/java -jar " . $upload_path . "office2pdf/jodconverter-2.2.2/lib/jodconverter-cli-2.2.2.jar " . $input_file . " " . $out_file;
                exec($file);
                Storage::move($path,$type.'/'.$file_name);
                Storage::move($path.'.pdf',$type.'/'.$file_name.'.pdf');
                //$imgfiles = pdf2img($upload_path.$type.'/'.$file_name.'.pdf');
                //return response()->json(['msg' => $path . '.pdf', 'imgfiles' => $imgfiles]);
                // return response()->json(['msg' => $path . '.pdf']);
                return response()->json(['msg' => $type.'/'.$file_name. '.pdf']);
            }

        }
    }

}


windows@pdf转图片
function pdf2img_of_windows($pdf)
{

    if (!extension_loaded('imagick')) {
        return false;
    }
    if (!file_exists($pdf)) {
        return false;
    }

    $imgpath=explode('.',$pdf)[0];
    mkdirs($imgpath);
    $im = new Imagick();
    $im->setResolution(120, 120); //设置分辨率 值越大分辨率越高
    $im->setCompressionQuality(100);
    $im->readImage($pdf);
    foreach ($im as $k => $v) {
        $v->setImageFormat('png');
        $fileName = $imgpath .'/'. ($k+1) .  '.png';
        if ($v->writeImage($fileName) == true) {
            $return[] =substr(strrchr($fileName,'/'),1);
        }
    }
    return $return;
}

linux@pdf转图片
function pdf2img_of_linux($pdf)
{
    $imgpath=strstr($pdf,'.pdf',true);
    if(strrpos($imgpath,'.ppt')){
        $imgpath=strstr($imgpath,'.ppt',true);
    }elseif (strrpos($imgpath,'.pptx')) {
        $imgpath=strstr($imgpath,'.pptx',true);
    }elseif (strrpos($imgpath,'.doc')) {
        $imgpath=strstr($imgpath,'.doc',true);
    }elseif (strrpos($imgpath,'.docx')) {
        $imgpath=strstr($imgpath,'.docx',true);
    }elseif (strrpos($imgpath,'.xls')) {
        $imgpath=strstr($imgpath,'.xls',true);
    }elseif (strrpos($imgpath,'.xlsx')) {
        $imgpath=strstr($imgpath,'.xlsx',true);
    }
    //$imgpath=explode('.',$pdf)[0];
    $save_to=$imgpath.'/img.png 2>&1';
    mkdirs($imgpath);//检查是否存在目录，没有就创建
    $file = "/usr/local/imagemagick/bin/convert ".$pdf.' '.$save_to;
    exec($file,$status,$result);
    //打开目录
    $handler = opendir($imgpath);
    /*其中$filename = readdir($handler)
    每次循环时将读取的文件名赋值给$filename，$filename !== false。
    一定要用!==，因为如果某个文件名如果叫'0′，或某些被系统认为是代表false，用!=就会停止循环
    */
    $images_arr=[];
    $temp=[];
    while( ($filename = readdir($handler)) !== false )
    {
        //略过linux目录的名字为'.'和‘..'的文件
        if($filename != '.' && $filename != '..')
        {
            $filename=substr($filename,strpos($filename, '-')+1);
            $temp[]=strstr($filename,'.',true);
        }
    }
     sort($temp);
    foreach ($temp as $key => $value) {
        $images_arr[] = 'img-'.$value.'.png';
    }
    return $images_arr;
}

/********************************************************************************/

视频上传类
class NewVideoUploadController extends Controller
{
    const KC_FFMPEG_PATH= 'ffmpeg -i "%s" 2>&1';
    // 允许上传文件类型
    protected $allowed_ext = ['avi', 'mp4',];

    public function save($file, $folder)
    {
        //return $this->getVideoCoding($file);
        if (($file->getClientSize() / 1024 / 1024) > 400) {
            return response()->json(["上传的文件大小大于 400 M, 请压缩之后上传"], 422);
        }
        // 构建存储的文件夹规则，值如：uploads/images/avatars/201709/21/
        // 文件夹切割能让查找效率更高。
        //$folder_name = "videos/$folder/" . date("Ym/d", time());
        $folder_name = "$folder/" . date("Ym/d", time());

        // 文件具体存储的物理路径，`public_path()` 获取的是 `public` 文件夹的物理路径。
        // 值如：/home/vagrant/Code/larabbs/public/uploads/images/avatars/201709/21/
        $upload_path = public_path() . '/uploads/' . $folder_name;

        // 获取文件的后缀名，因文件可能从剪贴板里黏贴时后缀名为空，所以此处确保后缀一直存在
        $extension = strtolower($file->getClientOriginalExtension()) ?: 'mp4';

        // 拼接文件名
        $filename = time() . '_' . str_random(10) . '.' . $extension;

        // 如果上传的不是视频将终止操作
        if (!in_array($extension, $this->allowed_ext)) {
            return response()->json(["上传的文件格式必须是 'avi', 'mp4' 格式类型"], 422);
        }

        // 将文件移动到我们的目标存储路径中
        $file->move($upload_path, $filename);

        return response()->json(['msg' => "$folder_name/$filename"], 201);
    }

    //获取视频编码@2020-7-13
    public function getVideoCoding($file)
    {
        ob_start();
        //执行命令，类似exec函数,该步骤耗时较长
        passthru(sprintf(self::KC_FFMPEG_PATH, $file));
        $info = ob_get_contents();
        ob_end_clean();

        /*if (preg_match("/Duration: (.*?), start: (.*?), bitrate: (\d*) kb\/s/", $info, $match)) {
            $ret['duration'] = $match[1]; // 提取出播放时间
            $da = explode(':', $match[1]);
            $ret['seconds'] = $da[0] * 3600 + $da[1] * 60 + $da[2]; // 转换为秒
            $ret['start'] = $match[2]; // 开始时间
            $ret['bitrate'] = $match[3]; // bitrate 码率 单位 kb

        }*/

        // Stream #0.1: Video: rv40, yuv420p, 512x384, 355 kb/s, 12.05 fps, 12 tbr, 1k tbn, 12 tbc
        if (preg_match("/Video: (.*?), (.*?), (.*?)[,\s]/", $info, $match)) {
            $ret['vcodec'] = $match[1]; // 编码格式
            //$ret['vformat'] = $match[2]; // 视频格式
            //$ret['resolution'] = $match[3]; // 分辨率
            //$a = explode('x', $match[3]);
            //$ret['width'] = $a[0];
            //$ret['height'] = $a[1];
        }

        //return $ret;
        // Stream #0.0: Audio: cook, 44100 Hz, stereo, s16, 96 kb/s
        /*if (preg_match("/Audio: (\w*), (\d*) Hz/", $info, $match)) {
            $ret['acodec'] = $match[1]; // 音频编码
            $ret['asamplerate'] = $match[2]; // 音频采样频率

        }*/
        /*if (isset($ret['seconds']) && isset($ret['start'])) {
            $ret['play_time'] = $ret['seconds'] + $ret['start']; // 实际播放时间

        }*/

        if(!strstr($ret['vcodec'],'h264')){
            return response()->json(["上传视频的编码格式必须是h264格式,"], 422);
        }
    }


     //视频上传
    public function upload(VideoUploadHandlerRequest $request)
    {
        return $this->save($request->clientfile, $request->type);
    }

}

/********************************************************************************/


Excle导入类 "maatwebsite/excel": "~2.1.0"
class ImportController extends Controller
{
    public function userImport(Request $request)
    {
        $filetype = ($request->clientfile)->getClientOriginalExtension();
        // 检测文件上传格式
        if (!in_array($filetype, [
            'xlsx',
            'xls'
        ])) {
            return response()->json(["上传的文件格式必须是 'xlsx', 'xls' 格式类型"], 422);
        }
        $student_nums = \DB::table('stu')->pluck('student_num')->toArray();
        //var_dump($student_nums);die();

        //是否存在相同账号的标识
        $flag = 0;
        $alredy_has_stu_num = [];//记录导入的数据中有哪些账号是重复的

        //判断表头名称是否有效的标识
        $student_name_flag = 0;//学生姓名
        $student_number_flag = 0;//学生账号
        $student_sex_flag = 0;//性别
        $student_tel_flag = 0;//手机号
        $student_pwd_flag = 0;//密码

        //是否全部导入成功的标识
        $total_import_flag = 0;

        \DB::beginTransaction();
        try {
            \Excel::load($request->clientfile, function ($reader) use ($request, $student_nums, &$flag, &$alredy_has_stu_num, &$student_name_flag, &$student_number_flag, &$student_sex_flag, &$student_tel_flag, &$student_pwd_flag, &$total_import_flag) {
                // 获取所有数据
                $sheet = $reader->getSheet(0)->toArray();
                //var_dump($sheet);die();
                //记录表头行
                $GLOBALS['sheet_one_line'] = $sheet[0];
                unset($sheet[0]);

                //计算导入题型数量
                $GLOBALS['sheet_length'] = count($sheet);

                foreach ($sheet as $v) {
                    if (in_array($v[1], $student_nums)) {
                        $flag++;
                        $alredy_has_stu_num[] = $v[1];
                    }


                    //学生姓名
                    if ($GLOBALS['sheet_one_line'][0] == "学生姓名") {
                        $student_name = $v[0];
                    } else {
                        $student_name = null;
                        $student_name_flag++;
                    }

                    //学生账号
                    if ($GLOBALS['sheet_one_line'][1] == "学生账号") {
                        $student_num = $v[1];
                    } else {
                        $student_num = null;
                        $student_number_flag++;
                    }

                    //性别
                    if ($GLOBALS['sheet_one_line'][2] == "性别" && $v[2] == '女') {
                        $student_sex = '1';
                    } else if ($GLOBALS['sheet_one_line'][2] == "性别" && $v[2] == '男') {
                        $student_sex = '0';
                    } else {
                        $student_sex = null;
                        $student_sex_flag++;
                    }

                    //手机号
                    if ($GLOBALS['sheet_one_line'][3] == "手机号") {
                        $student_tel = $v[3];
                    } else {
                        $student_tel = null;
                        $student_tel_flag++;
                    }

                    //密码
                    if ($GLOBALS['sheet_one_line'][4] == "密码") {
                        $student_pwd = $v[4];
                    } else {
                        $student_pwd = null;
                        $student_pwd_flag++;
                    }

                    if ($student_name && $student_num && ($student_sex = '0' || $student_sex = '1') && $student_tel && $student_pwd) {
                        $total_import_flag++;
                        Stu::create([
                            'student_name'  => $student_name,
                            'student_num'   => $student_num,
                            'sex'           => $student_sex,
                            'mobile'        => $student_tel,
                            'password'      => md5($student_pwd),
                            'class_id'      => $request->class_id,
                            'create_userid' => $request->create_userid,
                            'org_id'        => $request->org_id,
                            'created_at'    => Carbon::now(),
                            'updated_at'    => Carbon::now(),
                        ]);
                    }

                }
            });
            if (($student_name_flag == $GLOBALS['sheet_length']) || ($student_number_flag == $GLOBALS['sheet_length']) || ($student_sex_flag == $GLOBALS['sheet_length']) || ($student_tel_flag == $GLOBALS['sheet_length']) || ($student_pwd_flag == $GLOBALS['sheet_length'])) {
                //表头不对
                $err_info = [
                    'error' => [
                        "code"      => "ERR-UNPROCESSABLEENTITY",
                        "http_code" => 422,
                        "message"   => "表头格式错误,导入失败！",
                    ]
                ];
                return response()->json($err_info, 422);
            } else if ($flag > 0) {
                //账号有重复
                $info = [
                    'error' => [
                        "code"      => "ERR-UNPROCESSABLEENTITY",
                        "http_code" => 422,
                        "message"   => "导入失败,上传表格中以下学生账号:" . implode(',', $alredy_has_stu_num) . "在系统中已存在",
                    ]
                ];
                return response()->json($info, 422);
            } else {
                if ($total_import_flag == $GLOBALS['sheet_length']) {
                    \DB::commit();
                    return response()->json(['msg' => $filetype . ' 导入成功！'], 200);
                } else {
                    \DB::commit();
                    return response()->json(['msg' => $filetype . ' 部分导入成功！'], 200);
                }
            }
        } catch (\Exception $e) {
            \DB::rollBack();
            return $e;
        }

    }
}

Excle导出类
class ExprortController extends Controller
{
    //导出本次成绩
    public function export(Request $request)
    {
        // 需要导出的数据
        $exam_count = ExamResult::where([
            'exam_arrangement_id' => $request->exam_arrangement_id,
            'class_id'            => $request->class_id,
        ])->get();
        return $this->doExport($request, $exam_count);
    }

     //执行导出 excel 操作
    private function doExport($request, $exam_count)
    {
        // 导出的 excel 名称
        $exam_info = Exam::find($request->exam_id);
        if ($exam_info) {
            $name = $exam_info->name . '考试成绩统计';
        } else {
            $name = '考试成绩统计';
        }

        // 格式化导出的数据
        if ($exam_count) {
            foreach ($exam_count as $key => $value) {
                $student = Stu::find($value->student_id);
                if ($student) {
                    ($exam_count[$key])->student_name = $student->student_name;
                }
                ($exam_count[$key])->exam_time = $value->exam_begin_time . ' ~ ' . $value->exam_end_time;
                unset($value->exam_arrangement_id);
                unset($value->class_id);
                unset($value->exam_paper_id);
                unset($value->student_id);
                unset($value->exam_begin_time);
                unset($value->exam_end_time);
                unset($value->pass_score);
                unset($value->total_score);
                unset($value->created_at);
                unset($value->updated_at);
                unset($value->lib_product_recognition_summary_score);
            }
        }

        // 创建 excel
        \Excel::create($name, function ($excel) use ($exam_count) {
            $excel->sheet('考试成绩统计', function ($sheet) use ($exam_count) {
                $sheet->appendRow([
                    'id',
                    '考试总分',
                    '判断题得分',
                    '单选题得分',
                    '多选题得分',
                    //'认识库得分',
                    '流程库得分',
                    '考试状态',
                    '考生姓名',
                    '考试时间',
                ]);
                $rows = [];
                foreach ($exam_count as $value) {
                    $rows[] = [
                        $value->id,
                        $value->summary_score,
                        $value->judjement_question_summary_score,
                        $value->single_choice_question_summary_score,
                        $value->multiple_choice_question_summary_score,
                        //$value->lib_product_recognition_summary_score,
                        $value->lib_process_summary_score,
                        $value->exam_status,
                        $value->student_name,
                        $value->exam_time,
                    ];
                }
                $sheet->rows($rows);
                // 设置单元格宽度
                $sheet->setWidth([
                    'A' => 5,
                    'B' => 15,
                    'C' => 15,
                    'D' => 15,
                    'E' => 15,
                    'F' => 15,
                    'G' => 15,
                    'H' => 15,
                    'I' => 40,
                    //'J' => 40,
                ]);
            });
        })->export('xlsx');
    }
   
}

/********************************************************************************/

百度人脸比对类：
class Baidu 
{
       //2020-3-5错误信息
    protected $msg = [
        4      => '集群超限额',
        6      => '没有接口权限',
        17     => '每天流量超限额',
        18     => 'QPS超限额',
        19     => '请求总量超限额',
        100    => '无效的access_token参数',
        110    => 'Access Token失效',
        111    => 'Access token过期',
        222001 => '必要参数未传入',
        222002 => '参数格式错误',
        222003 => '参数格式错误',
        222004 => '参数格式错误',
        222005 => '参数格式错误',
        222006 => '参数格式错误',
        222007 => '参数格式错误',
        222008 => '参数格式错误',
        222009 => '参数格式错误',
        222010 => '参数格式错误',
        222011 => '参数格式错误',
        222012 => '参数格式错误',
        222013 => '参数格式错误',
        222014 => '参数格式错误',
        222015 => '参数格式错误',
        222016 => '参数格式错误',
        222017 => '参数格式错误',
        222018 => '参数格式错误',
        222019 => '参数格式错误',
        222020 => '参数格式错误',
        222021 => '参数格式错误',
        222022 => '参数格式错误',
        222023 => '参数格式错误',
        222024 => '参数格式错误',
        222025 => '参数格式错误',
        222026 => '参数格式错误',
        222027 => '验证码长度错误(最小值大于最大值)',
        222028 => '参数格式错误',
        222029 => '参数格式错误',
        222030 => '参数格式错误',
        222200 => '该接口需使用application/json的格式进行请求',
        222201 => '服务端请求失败',
        222202 => '图片中没有人脸',
        222203 => '无法解析人脸',
        222204 => '从图片的url下载图片失败',
        222205 => '服务端请求失败',
        222206 => '服务端请求失败',
        222207 => '未找到匹配的用户',
        222208 => '图片的数量错误',
        222209 => 'face token不存在',
        222210 => '人脸库中用户下的人脸数目超过限制',
        222300 => '人脸图片添加失败',
        222301 => '获取人脸图片失败',
        222302 => '服务端请求失败',
        222303 => '获取人脸图片失败',
        223100 => '操作的用户组不存在',
        223101 => '该用户组已存在',
        223102 => '该用户已存在',
        223103 => '找不到该用户',
        223104 => 'group_list包含组数量过多',
        223105 => '该人脸已存在',
        223106 => '该人脸不存在',
        223110 => 'uid_list包含数量过多',
        223111 => '目标用户组不存在',
        223112 => 'quality_conf格式不正确',
        223113 => '人脸有被遮挡',
        223114 => '人脸模糊',
        223115 => '人脸光照不好',
        223116 => ' 人脸不完整',
        223117 => 'app_list包含app数量过多',
        223118 => '质量控制项错误',
        223119 => '活体控制项错误',
        223120 => '活体检测未通过',
        223121 => '质量检测未通过 左眼遮挡程度过高',
        223122 => '质量检测未通过 右眼遮挡程度过高',
        223123 => '质量检测未通过 左脸遮挡程度过高',
        223124 => '质量检测未通过 右脸遮挡程度过高',
        223125 => '质量检测未通过 下巴遮挡程度过高',
        223126 => '质量检测未通过 鼻子遮挡程度过高',
        223127 => '质量检测未通过 嘴巴遮挡程度过高',
        222901 => '参数校验初始化失败',
        222902 => '参数校验初始化失败',
        222903 => '参数校验初始化失败',
        222904 => '参数校验初始化失败',
        222905 => '接口初始化失败',
        222906 => '接口初始化失败',
        222907 => '缓存处理失败',
        222908 => '缓存处理失败',
        222909 => '缓存处理失败',
        222910 => '数据存储处理失败',
        222911 => '数据存储处理失败',
        222912 => '数据存储处理失败',
        222913 => '接口初始化失败',
        222914 => '接口初始化失败',
        222915 => '后端服务连接失败',
        222916 => '后端服务连接失败',
        222304 => '图片尺寸太大',
        223128 => '正在清理该用户组的数据',
        222361 => '公安服务连接失败',
        222046 => '参数格式错误',
        222101 => '参数格式错误',
        222102 => '参数格式错误',
        222307 => '图片非法 鉴黄未通过',
        222308 => '图片非法 含有政治敏感人物',
        222211 => '人脸融合失败 模板图质量不合格',
        222212 => '人脸融合失败',
        223129 => '人脸未面向正前方（人脸的角度信息大于30度）',
    ];

    //2020-3-5获取百度人脸比对token
    public function getToken()
    {
        $token = \Cache::get('baidu_face_access_token');
        if (!$token) {
            //获取token
            $client_id = config('services.baidu.api_key');
            $client_key = config('services.baidu.secret_key');
            $access_token_url = "https://openapi.baidu.com/oauth/2.0/token?grant_type=client_credentials&client_id=" . $client_id . "&client_secret=" . $client_key;
            $response = http_get($access_token_url);
            $response = json_decode($response, true);
            $token = $response['access_token'];
            $expires_in = $response['expires_in'];
            if ($token && $expires_in) {
                \Cache::put('baidu_face_access_token', $token, Carbon::now()->addSecond($expires_in));
            }
        }
        return $token;
    }

    //2020-3-5人脸识别CURL-POST请求
    public function request_post($url = '', $param = '')
    {
        if (empty($url) || empty($param)) {
            return false;
        }

        $postUrl = $url;
        $curlPost = $param;
        // 初始化curl
        $curl = curl_init();
        curl_setopt($curl, CURLOPT_URL, $postUrl);
        curl_setopt($curl, CURLOPT_HEADER, 0);
        // 要求结果为字符串且输出到屏幕上
        curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);
        curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, false);
        // post提交方式
        curl_setopt($curl, CURLOPT_POST, 1);
        curl_setopt($curl, CURLOPT_POSTFIELDS, $curlPost);
        // 运行curl
        $data = curl_exec($curl);
        curl_close($curl);

        return $data;
    }

    //2020-3-5图片base64
    public function base64EncodeImage($image_file)
    {
        $base64_image = '';
        $image_info = getimagesize($image_file);
        $image_data = fread(fopen($image_file, 'r'), filesize($image_file));
        //$base64_image = 'data:' . $image_info['mime'] . ';base64,' . chunk_split(base64_encode($image_data));
        $base64_image = chunk_split(base64_encode($image_data));
        /* $result=[
             'image_content'=>$base64_image,
         ];
         echo response()->json($result);*/
        return $base64_image;
    }


    public function faceCheck($request)
    {
        $db_photo = \DB::table('wechat_user')->where('id', $request->wechat_user_id)->value('photo');
        $upload_path = public_path() . '/uploads/';
        $upload_path = str_replace('\\', '/', $upload_path);
        $up_image_base = $this->base64EncodeImage($upload_path . $request->up_image);
        $db_image_base = $this->base64EncodeImage($upload_path . $db_photo);


        $token = $this->getToken();
        $url = $url = 'https://aip.baidubce.com/rest/2.0/face/v3/match?access_token=' . $token;
        $bodys = [
            [
                'image'      => $up_image_base,
                'image_type' => 'BASE64',
                'face_type'  => 'LIVE',
            ],
            [
                'image'      => $db_image_base,
                'image_type' => 'BASE64',
                'face_type'  => 'LIVE',
            ],
        ];
        $bodys = json_encode($bodys);
        $res = $this->request_post($url, $bodys);
        $res = json_decode($res, true);
        if (in_array($res['error_code'], array_keys($this->msg))) {
            $res['error_msg_info'] = array_get($this->msg, $res['error_code']);
        } else {
            $res['error_msg_info'] = null;
        }
        if ($res['result'] && $res['result']['score'] >= 80) {
            \DB::table('wechat_user')->where('id', $request->wechat_user_id)->update(['check_face_image' => $request->up_image]);
            return response()->json(['msg' => "人脸比对成功通过！"], 200);
        } else if ($res['result'] && $res['result']['score'] < 80) {
            return $this->errorUnprocessableEntity('人脸比对失败！');
        } else {
            return $this->errorUnprocessableEntity($res['error_msg_info']);
        }
    }


    //身份证图片文字识别
    public function wordCheck_getToken()
    {
        $token = \Cache::get('baidu_word_access_token');
        if (!$token) {
            //获取token
            $client_id = 'jFoOFHSOPZ1PW8Yute49Y0TR';
            $client_key = 'XA1EGnrkSMBNqeh3z3HbkOmlYDj6CqW5';
            $access_token_url = "https://openapi.baidu.com/oauth/2.0/token?grant_type=client_credentials&client_id=" . $client_id . "&client_secret=" . $client_key;
            $response = http_get($access_token_url);
            $response = json_decode($response, true);
            $token = $response['access_token'];
            $expires_in = $response['expires_in'];
            if ($token && $expires_in) {
                \Cache::put('baidu_word_access_token', $token, Carbon::now()->addSecond($expires_in));
            }
        }
        return $token;
    }
    public function wordCheck($request)
    {
        $upload_path = public_path() . '/uploads/';
        $upload_path = str_replace('\\', '/', $upload_path);
        $url='https://aip.baidubce.com/rest/2.0/ocr/v1/idcard?access_token='.$this->wordCheck_getToken();
         $img = file_get_contents($upload_path.$request->up_image);
        $img = base64_encode($img);
        $bodys = array(
            'id_card_side' => "front",
            'image' => $img
        );
        $res = $this->request_post($url, $bodys);
        return response()->json(json_decode($res,true));
    } 


        //文字转语音
    public function textToAudio(Request $request)
    {
        $token = \Cache::get('baidu_access_token');
        if (!$token) {
            //获取token
            $client_id = config('services.baidu.api_key');
            $client_key = config('services.baidu.secret_key');
            $access_token_url = "https://openapi.baidu.com/oauth/2.0/token?grant_type=client_credentials&client_id=" . $client_id . "&client_secret=" . $client_key;
            $response = http_get($access_token_url);
            $response = json_decode($response, true);
            $token = $response['access_token'];
            $expires_in = $response['expires_in'];
            if ($token && $expires_in) {
                \Cache::put('baidu_access_token', $token, Carbon::now()->addSecond($expires_in));
            }
        }
        //获取语音
        $stu_info = \DB::table('stu')->select([
            'id',
            'student_name',
            'org_id'
        ])->find($request->get('id'));
        $text = '请' . $stu_info->student_name . '同学回答问题';
        $per = [
            '度小美' => 0,
            '度小宇' => 1,
            '度逍遥' => 3,
            '度丫丫' => 4,
            '度博文' => 106,
            '度小童' => 110,
            '度小萌' => 111,
            '度米朵' => 103,
            '度小娇' => 5
        ];
        $params = [
            'tex' => urlencode($text),
            'per' => $per['度丫丫'],
            'spd' => 5,
            'pit' => 5,
            'vol' => 5,
            'aue' => 3,
            'cuid' => 'E0-3F-49-A1-83-34',
            'tok' => $token,
            'lan' => 'zh',
            'ctp' => 1,
        ];
        $paramsStr = http_build_query($params);
        $url = 'http://tsn.baidu.com/text2audio';
        $get_audio_url = $url . '?' . $paramsStr;

        //下载音频
        $g_has_error = true;
        $ch = curl_init();
        curl_setopt($ch, CURLOPT_URL, $url);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);
        curl_setopt($ch, CURLOPT_POST, 1);
        curl_setopt($ch, CURLOPT_POSTFIELDS, $paramsStr);
        curl_setopt($ch, CURLOPT_HEADERFUNCTION, [
            $this,
            'read_header'
        ]);
        $data = curl_exec($ch);
        if (curl_errno($ch)) {
            echo curl_error($ch);
            exit(2);
        }
        curl_close($ch);
        //$file = $g_has_error ? public_path()."/result.txt" : public_path()."/result.mp3";
        //file_put_contents($file, $data);
        $org_sign = \DB::table('manager')->where('id', $stu_info->org_id)->value('org_sign');
        $file_name = '/' . $org_sign . "/text_2_audio/" . date("Ym/d", time()) . '/' . time() . str_random(10) . '.mp3';
        \Storage::put($file_name, $data);
        return response()->json(['msg' => substr($file_name, 1)], 201);
    }

    //文字转语音-响应头回调处理函数
    public function read_header($ch, $header)
    {
        global $g_has_error;
        $comps = explode(":", $header);
        // 正常返回的头部 Content-Type: audio/*
        // 有错误的如 Content-Type: application/json
        if (count($comps) >= 2) {
            if (strcasecmp(trim($comps[0]), "Content-Type") == 0) {
                if (strpos($comps[1], "audio/") > 0) {
                    $g_has_error = false;
                } else {
                    echo $header . " , has error \n";
                }
            }
        }
        return strlen($header);
    }
   
}
